#######################################################################
## should be define by your particle mode (spheres or polyhedra)
move_particles_extra_data: nop
compute_new_vertices: nop # after update ghost
reorder_extra_data: nop

########### Generic particle update block ################

# define a test node which outputs a boolean value 'trigger_move_particles'
# which tells when to move particles across cells and update neighbor lists
trigger_move_particles:
  rebind: { threshold: max_displ , result: trigger_move_particles }
  body: 
    - particle_displ_over


################### AMR ############################
rebuild_amr:
  sub_grid_density: 6.5
  amr_z_curve: false
  enforced_ordering: 1
####################################################


################### Neighbor list update ############################
chunk_neighbors_contact:
  config:
    free_scratch_memory: true
    build_particle_offset: false
    subcell_compaction: true
    scratch_mem_per_cell: 1048576
    stream_prealloc_factor: 1.05
    chunk_size: 1

chunk_neighbors_impl: 
  - chunk_neighbors_contact

update_particle_neighbors:
  - amr_grid_pairs
  - chunk_neighbors_impl
  - resize_particle_locks
####################################################################

grid_post_processing: grid_memory_compact

ghost_full_update:
  - ghost_comm_scheme
  - ghost_update_all
  - compute_new_vertices

  
################## trigger stl mesh update ########################

trigger_update_stl_mesh:
  condition: enable_stl_mesh
  body:
    - build_grid_stl_mesh

################### parallel particle migration ############################

## These operator should be define by your particle mode (spheres or polyhedra)
migrate_particles: nop
add_generated_particles: nop

parallel_update_particles:
  - particle_generator:
      condition: trigger_generator
      body: 
         - add_generated_particles
  - migrate_particles
  - ghost_full_update
  - grid_post_processing
  - update_particle_neighbors
  - trigger_update_stl_mesh

# define actions to initialize particles at startup, just after file read
init_particles:
  - move_particles # standard move_particles, even if friction is enabled. just re-order particles in cells, if needed
  - extend_domain
  - load_balance
  - parallel_update_particles
###########################################################################

########################### Load balancing ############################
# trigger load balance whenever domain size changed, whatever freq has been requested
# extend_domain has an input named enable_domain_extension to control if domain extesion is allowed
# enable_domain_extension is defined as false in 'global'
trigger_load_balance:
  - trigger_lb_tmp:
      condition: enable_load_balance
      rebind: { result: trigger_lb_tmp , freq: simulation_load_balance_frequency }
      body:
        - nth_timestep: { first: false , delayed: true }
  - extend_domain
  - combine:
      rebind: { in1: trigger_lb_tmp , in2: domain_extended , result: trigger_load_balance }
      body: [ boolean_or ]

# define how load balancing is done
load_balance:
#  - simple_cost_model: { ccost: 1.0 , pdens: 40.0 , pdens2:0.0 , pdens3:0.000 }
  - simple_cost_model: { cost_model_coefs: [2,10,4,1] }
  - load_balance_rcb
#  - cpu_gpu_load_balance

load_balancing_if_triggered:
  condition: trigger_load_balance
  body:
    - load_balance

update_particles_full_body:
  - move_particles_extra_data
  - trigger_load_balance
  - load_balancing_if_triggered
  - parallel_update_particles
  - reorder_extra_data

update_particles_full:
  condition: trigger_move_particles
  body:
    - update_particles_full_body

update_particles_fast_body:
    - ghost_update_rq:
       gpu_buffer_pack: true
       async_buffer_pack: true #false
       staging_buffer: true
       serialize_pack_send: true
       wait_all: false
    - compute_new_vertices

update_particles_fast:
  condition: not trigger_move_particles
  body:
    - update_particles_fast_body

######################################################
############# Particle Generator #####################
######################################################
## if no particle generator, it follows the trigger_move_particles behavior
combine_particle_generator: 
  rebind: { in1: trigger_generator , in2: trigger_move_particles , result: trigger_move_particles }
  body: [ boolean_or ]

trigger_particle_generator:
  rebind: { freq: simulation_generator_frequency , result: trigger_generator }
  body:
    - nth_timestep: { first: false }

######################################################
check_and_update_particles:
  - trigger_move_particles
  - combine_particle_generator
  - update_particles_full
  - update_particles_fast
  - loadbalance_log_helper:
      rebind: { lb_flag: trigger_load_balance , move_flag: trigger_move_particles }
      body: [ lb_event_counter ]
